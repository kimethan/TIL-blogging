# greedy Algorithm

> 탐욕 알고리즘은 말 그대로 눈앞의 최적의 상황만을 해결하여 해답에 도달하는 방법이다.
> 

## 예시 1

---

*편의점에 손님이 와서 과자와 음료를 계산하려한다. 물건 가격은 총 4040원이고 계산을 위해 5000원을 내밀며 거스름돈은 동전의 갯수를 최소한으로 거슬러 달라고 하였다.*

---

우선 탐욕알고리즘의 해결 방법은 크게 3가지 절차로 나뉜다.

1. 선택절차(Selection Procedure) : 현재 상태에서 최적의 해답을 선택한다
2. 적절성 검사(Feasibility Check) : 선택된 해가 문제의 조건을 만족하는지 검사한다
3. 해답검사(Solution Check) : 원래의 문제가 해결되었는지 검사하고, 해결되지 않았다면 선택절차로 돌아가 위의 과정을 반복한다

위의 절차에 따라서 문제를 살펴보면 다음과 같다

1. 선택절차 : 거스름돈의 동전 개수를 줄이기 위해 현재 가장 가치가 높은 동전을 우선 탐색한다
2. 적절성 검사 : 1번 과정을 통해 선택된 동전들의 합이 거슬러 줄 금액을 초과하는지 검사한다. 초과한다면 가장 마지막에 선택한 동전을 삭제하고 1번으로 돌아가 한 단계 낮은 동전을 선택한다
3. 해답 검사 : 선택된 동전들의 합이 거슬러 줄 금액과 일치하는지 검사한다. 액수가 부족하다면 1번부터 다시 검사한다. 

## 예시 2

---

*집에 도둑이 들었다. 도둑의 가방은 35kg이며, 집에는 4개의 물건이 있다고 한다면 도둑이 최대로 비싸게 훔친 물건들은 무엇일까.*

- *액자 : 30kg, 30000원*
- *TV : 25kg, 25000원*
- *반지 : 15kg, 15000원*
- *모니터 : 20kg, 20000원*

---

이 문제도 탐욕 알고리즘으로 해결할 수 있다

1. 가방에 넣을 수 있는 가장 비싼 물건을 넣는다
2. 그다음으로 넣을 수 있는 가장 비싼 물건을 넣는다. 무게가 초과한다면 마지막에 넣은 물건 다음으로 비싼 물건을 넣는다
3. 넣은 물건의 합이 35kg가 초과하는지 검사한다. 초과한다면 1번부터 다시 검토한다. 

다만 이렇게 문제를 푼다면 도둑은 처음부터 가장 비싼 그림을 넣을것이고 그럴 경우 30000원 어치 밖에 훔치지 못한다.

반지와 모니터를 훔치면 35000원의 이득을 남길 수 있지만 말이다.

이렇듯 탐욕 알고리즘은 매 순간에서 최적의 해답을 찾아나가면서 문제를 해결하는 방식이다. 그렇다보니 항상 전체적인 결과가 최적이라는 것은 보장하지 못한다는 단점이 있다.

이러한 상황을 방지하기 위해서 탐욕 알고리즘은 두가지 조건을 만족하는 특정상황에서만 주로 사용된다.

- 탐욕적 선택속성(Greedy Choice Property) : 앞의 선택이 이후의 선택에 영향을 주지 않는다.
- 최적 부분 구조(Optimal Substructure) : 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 해결 방법으로 구성된다.

비록 탐욕 알고리즘은 최적의 결과를 도출하지는 않지만, 최적에 근사한 값을 도출하기 때문에 근사 알고리즘으로도 사용될 수 있다.

# 완전 탐색

> 무식하고 단순하지만 답을 무조건 찾을 수 있는 방법
> 

- *양의 정수 1부터 100까지 임의의 요소가 오름차순으로 하나씩 담긴 배열 중, 원하는 값 N을 찾으시오. 단, 시간 복잡도가 O(N)보다 낮아야 한다*

만약 위의 문제를 해결하기 위해 완전 탐색을 사용한다면 두가지 요소를 고려해야 한다

1. 문제를 해결할 수 있는가?
2. 효율적으로 동작하는가?

위의 두가지 조건 중 완전탐색은 2번째 조건을 만족하지 못한다. 따라서 완전탐색을 사용할 때는 문제를 풀 수 있는 모든 방법을 고려한 후, 효율적으로 동작하는 알고리즘이 완전 탐색밖에 없다고 할 때 적용가능하다

완전 탐색의 종류에는 brute Force(조건/ 반복문을 사용), 재귀, 순열, DFS/BFS 등이 있다

## 예시(brute Force)

---

> *우리 집에는 세 명의 아이들이 있습니다. 아이들의 식성은 까다로워, 먹기 싫은 음식과 좋아하는 음식을 철저하게 구분합니다. 
먹기 싫은 음식이 식탁에 올라왔을 땐 음식 냄새가 난다며 그 주변의 음식까지 전부 먹지 않고, 좋아하는 음식이 올라왔을 땐 해당 음식을 먹어야 합니다. 세 아이의 식성은 이렇습니다.
1. 첫째: (싫어하는 음식 - 미역국, 카레) (좋아하는 음식 - 소고기, 된장국, 사과)
2. 둘째: (싫어하는 음식 - 참치, 카레) (좋아하는 음식 - 미역국, 된장국, 바나나)
3. 셋째: (싫어하는 음식 - 소고기) (좋아하는 음식 - 돼지고기, 된장국, 참치)
100 개의 반찬이 일렬로 랜덤하게 담긴 상이 차려지고, 한 명씩 전부 먹을 수 있다고 할 때, 가장 많이 먹게 되는 아이와 가장 적게 먹게 되는 아이는 누구일까요? (단, 그 주변의 음식은 반찬의 앞, 뒤로 한정합니다.)*
> 

---

이 문제는 단순히 100개의 반찬을 첫째, 둘째, 셋째의 식성에 맞게 대입하여 풀 수 있다.

```jsx
for(let i = 0; i < 100; i++) {
	if(첫째 식성) {
		if(싫은 음식이 있다) {
			넘어간다
		}
	좋아하는 음식 카운트
	if(둘째 식성) {
		if(싫은 음식이 있다) {
			넘어간다
		}
	좋아하는 음식 카운트
	if(셋째 식성) {
		if(싫은 음식이 있다) {
			넘어간다
		}
	좋아하는 음식 카운트
}

return 많이 먹은 아이
```

# 시뮬레이션

> 모든 과정과 조건이 제시되어, 그 과정을 거친 결과가 무엇인지 확인하는 유형
> 

## 예시

---

*무엇을 위한 조직인지는 모르겠지만, 비밀스러운 비밀 조직 '시크릿 에이전시'는 소통의 흔적을 남기지 않기 위해 3 일에 한 번씩 사라지는 메신저 앱을 사용했습니다. 그러나 내부 스파이의 대화 유출로 인해 대화를 할 때 조건을 여러 개 붙이기로 했습니다. 해당 조건은 이렇습니다.*

- *캐릭터는 아이디, 닉네임, 소속이 영문으로 담긴 배열로 구분합니다.*
- *소속은 'true', 'false', 'null' 중 하나입니다.*
- *소속이 셋 중 하나가 아니라면 아이디, 닉네임, 소속, 대화 내용의 문자열을 전부 X로 바꿉니다.*
- *아이디와 닉네임은, 길이를 2진수로 바꾼 뒤, 바뀐 숫자를 더합니다.*
- *캐릭터와 대화 내용을 구분할 땐 `공백:공백`으로 구분합니다: ['Blue', 'Green', 'null'] : hello.*
- *띄어쓰기 포함, 대화 내용이 10 글자가 넘을 때, 내용에 `.,-+` 이 있다면 삭제합니다.*
- *띄어쓰기 포함, 대화 내용이 10 글자가 넘지 않을 때, 내용에 `.,-+@#$%^&*?!` 이 있다면 삭제합니다.*
- *띄어쓰기를 기준으로 문자열을 반전합니다: 'abc' -> 'cba'*
- *띄어쓰기를 기준으로 소문자와 대문자를 반전합니다: 'Abc' -> 'aBC'*

*시크릿 에이전시의 바뀌기 전 대화를 받아, 해당 조건들을 전부 수렴하여 수정한 대화를 객체에 키와 값으로 담아 반환하세요.* 

*같은 캐릭터가 두 번 말했다면, 공백을 한 칸 둔 채로 대화 내용에 추가되어야 합니다. 대화는 문자열로 제공되며, 하이픈`-` 으로 구분됩니다.*

*문자열은 전부 싱글 쿼터로 제공되며, 전체를 감싸는 문자열은 더블 쿼터로 제공됩니다.*

*예: "['Blue', 'Green', 'null'] : 'hello. im G.' - ['Black', 'red', 'true']: '? what? who are you?'"*

---

문제를 해결하기 위해 예시를 순차적으로 작성해본다

1. `"['Blue', 'Green', 'null'] : 'hello. im G.' - ['Black', 'red', 'true']: '? what? who are you?'"` 
    
    입력값으로 받은 문자열을 각 캐릭터와 대화에 맞게 문자열로 파싱하고, 파싱한 문자열을 상대로 캐릭터와 대화로 구분한다.
    
    - 첫 번째 파싱은 -을 기준으로 `"['Blue', 'Green', 'null'] : 'hello. im G.'`, `['Black', 'red', 'true']: '? what? who are you?'"`  두 부분으로 나뉜다.
    - 두번째 파싱은 : 을 기준으로 배열`['Blue', 'Green', 'null']` 과 문자열 `'hello. im G.'` 로 나뉜다.
2. 배열과 문자열을 사용해, 조건에 맞게 변형한다.
    - 소속이 셋중 하나인지 판별한다
    - `['Blue', 'Green', 'null']` 아이디와 닉네임의 길이를 2진수로 바꾼 뒤 숫자를 더한다. `[1, 2, 'null']`
    - `'hello. im G.'` 10글자가 넘기 때문에, `.,-+@#$%^&*` 를 삭제한다. `'hello im G'`
    - `'hello im G'` 띄어쓰기를 기준으로 문자열을 반전한다.`'olleh mi G'`
    - `'olleh mi G'` 소문자와 대문자를 반전한다.`'OLLEH MI g'`
3. 변형한 배열과 문자열을 키와 값으로 받아 객체에 넣는다.
    - `{ "[1, 2, 'null']": 'OLLEH MI g' }`

이렇듯 제시된 조건을 하나도 빠짐없이 처리해서 정답을 얻어내는 방식이다. 다만 하나라도 놓치게 된다면 길어진 코드 때문에 헷갈릴 수 있으니 꼼꼼하게 파악하는 것이 중요하다.
